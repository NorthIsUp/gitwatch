"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HomeassistantHomebridgePlatform = void 0;
const event_channel_1 = require("./event-channel");
const settings_1 = require("./settings");
const async_mqtt_1 = __importDefault(require("async-mqtt"));
const lockAccessory_1 = require("./accessories/lockAccessory");
const temperatureSensorAccessory_1 = require("./accessories/sensors/temperatureSensorAccessory");
const humiditySensorAccessory_1 = require("./accessories/sensors/humiditySensorAccessory");
/**
 * HomebridgePlatform
 * This class is the main constructor for your plugin, this is where you should
 * parse the user config and discover/register accessories with Homebridge.
 */
class HomeassistantHomebridgePlatform {
    constructor(log, config, api) {
        this.log = log;
        this.config = config;
        this.api = api;
        this.Service = this.api.hap.Service;
        this.Characteristic = this.api.hap.Characteristic;
        this.topicRegEx = new RegExp('^/([^/]+)/([^/]+)(?:/([^/]+))?/config$');
        // this is used to track restored cached accessories
        this.accessories = [];
        this.client = null;
        this.log.debug('Finished initializing platform:', this.config.name);
        // When this event is fired it means Homebridge has restored all cached accessories from disk.
        // Dynamic Platform plugins should only register new accessories after this event was fired,
        // in order to ensure they weren't added to homebridge already. This event can also be used
        // to start discovery of new accessories.
        this.api.on('didFinishLaunching', async () => {
            var _a, _b;
            log.debug('Executed didFinishLaunching callback');
            // run the method to discover / register your devices as accessories
            //this.discoverDevices();
            log.info(`Configuration: ${JSON.stringify(this.config)}`);
            try {
                log.info(`Connecting to ${this.config.host}`);
                this.client = await async_mqtt_1.default.connectAsync(`${this.config.protocol}://${this.config.host}:${this.config.port}`, {
                    username: this.config.username,
                    password: this.config.password,
                }, true);
                log.info(`connected to ${this.config.protocol}://${this.config.username}@${this.config.host}:${this.config.port}`);
                log.info('registering MQTT message handler');
                (_a = this.client) === null || _a === void 0 ? void 0 : _a.on('message', async (topic, payload) => {
                    if (topic !== null) {
                        if (topic.startsWith(this.config.homeassistantBaseTopic)) {
                            this.log.info(`Received configuration on topic '${topic}'`);
                            if (payload !== null) {
                                try {
                                    const jsonPayload = JSON.parse(payload.toString());
                                    this.handleDeviceConfiguration(topic, jsonPayload);
                                }
                                catch (e) {
                                    this.log.error(`error handling payload on topic ${topic} - ${JSON.stringify(e)}`);
                                }
                            }
                            else {
                                this.log.warn('payload was empty');
                            }
                        }
                        else {
                            this.log.info(`Received event message in ${topic}`);
                            this.log.info(`Payload: ${payload.toString()}`);
                            const accessory = this.accessories.find((accessory) => accessory.context.configuration.state_topic === topic ||
                                accessory.context.configuration.command_topic === topic);
                            if (accessory) {
                                if (topic === (accessory === null || accessory === void 0 ? void 0 : accessory.context.configuration.state_topic)) {
                                    this.log.debug(`publishing event ${accessory.UUID}:set-current-state} for topic ${topic}`);
                                    event_channel_1.EventEmitter.emit(`${accessory.UUID}:set-current-state`, { payload: payload.toString() });
                                }
                                else if (topic === accessory.context.configuration.command_topic) {
                                    this.log.debug(`publishing event ${accessory.UUID}:get-target-state} for topic ${topic}`);
                                    event_channel_1.EventEmitter.emit(`${accessory.UUID}:get-target-state`, { payload: payload.toString() });
                                }
                                else {
                                    this.log.warn(`have not found an accessory for topic ${topic}`);
                                }
                            }
                            else {
                                this.log.warn(`have not found an accessory for topic ${topic}`);
                            }
                        }
                    }
                    else {
                        this.log.warn('Received a message but topic was not set');
                    }
                });
                log.info(`subscribing to topic "${this.config.homeassistantBaseTopic}/#"`);
                (_b = this.client) === null || _b === void 0 ? void 0 : _b.subscribe(`${this.config.homeassistantBaseTopic}/#`);
            }
            catch (e) {
                log.error(JSON.stringify(e));
            }
        });
    }
    /**
     * This function is invoked when homebridge restores cached accessories from disk at startup.
     * It should be used to setup event handlers for characteristics and update respective values.
     */
    configureAccessory(accessory) {
        this.log.info('Loading accessory from cache:', accessory.displayName);
        // add the restored accessory to the accessories cache so we can track if it has already been registered
        this.accessories.push(accessory);
    }
    handleDeviceConfiguration(topic, configuration) {
        this.log.debug(`Handling device configuration received on topic "${topic}"`);
        const configurationTopic = topic.substring(this.config.homeassistantBaseTopic.length);
        const result = this.topicRegEx.exec(configurationTopic);
        if (result !== null) {
            const deviceType = result[1];
            const uuid = this.api.hap.uuid.generate(configuration.unique_id);
            const existingAccessory = this.accessories.find((accessory) => accessory.UUID === uuid);
            if (deviceType === 'lock') {
                this.handleLockConfiguration(uuid, existingAccessory, configuration);
            }
            else if (deviceType === 'sensor') {
                if (configuration.device_class) {
                    if (configuration.device_class === 'temperature') {
                        this.handleTemperatureSensorConfiguration(uuid, existingAccessory, configuration);
                    }
                    else if (configuration.device_class === 'humidity') {
                        this.handleHumiditySensorConfiguration(uuid, existingAccessory, configuration);
                    }
                    else {
                        this.log.warn(`found a currently unsupported device_class '${configuration.device_class}' - ignoring sensor`);
                    }
                }
                else {
                    this.log.warn(`Found a sensor without a device_class specified - It will be ignored (${topic})`);
                }
            }
            else {
                this.log.warn(`Unhandled device type ${deviceType}`);
            }
        }
        else {
            this.log.error(`Failed to extract configuration details from topic "${topic}"`);
        }
    }
    handleLockConfiguration(uuid, existingAccessory, configuration) {
        var _a, _b;
        const lockConfiguration = configuration;
        let usedAccessory;
        if (existingAccessory) {
            this.log.info(`Found an accessory with UUID ${uuid}`);
            new lockAccessory_1.LockPlatformAccessory(this, existingAccessory);
            usedAccessory = existingAccessory;
        }
        else {
            this.log.info(`No accessory found with UUID ${uuid}`);
            this.log.info('Creating a new lock accessory');
            const accessory = new this.api.platformAccessory(lockConfiguration.name, uuid);
            // store a copy of the device object in the `accessory.context`
            // the `context` property can be used to store any data about the accessory you may need
            accessory.context.device_type = 'lock';
            accessory.context.configuration = lockConfiguration;
            // create the accessory handler for the newly create accessory
            // this is imported from `platformAccessory.ts`
            new lockAccessory_1.LockPlatformAccessory(this, accessory);
            // link the accessory to your platform
            this.api.registerPlatformAccessories(settings_1.PLUGIN_NAME, settings_1.PLATFORM_NAME, [accessory]);
            usedAccessory = accessory;
        }
        (_a = this.client) === null || _a === void 0 ? void 0 : _a.subscribe(usedAccessory.context.configuration.state_topic);
        (_b = this.client) === null || _b === void 0 ? void 0 : _b.subscribe(usedAccessory.context.configuration.command_topic);
        event_channel_1.EventEmitter.on(`${usedAccessory.UUID}:set-target-state`, async (payload) => {
            var _a;
            this.log.debug(`Publish payload (${payload}) to topic ${usedAccessory.context.configuration.command_topic}`);
            let actualPayload = '';
            if (payload !== null && payload.payload !== null) {
                if (typeof payload.payload === 'string') {
                    this.log.debug('received payload is of type string - just passing it on');
                    actualPayload = payload.payload;
                }
                else {
                    this.log.debug('received payload is not of type string - JSON.stringify applied');
                    actualPayload = JSON.stringify(payload.payload);
                }
            }
            (_a = this.client) === null || _a === void 0 ? void 0 : _a.publish(usedAccessory.context.configuration.command_topic, actualPayload);
        });
    }
    handleTemperatureSensorConfiguration(uuid, existingAccessory, configuration) {
        var _a;
        let usedAccessory;
        if (existingAccessory) {
            this.log.info(`Found an accessory with UUID ${uuid}`);
            new temperatureSensorAccessory_1.TemperatureSensorPlatformAccessory(this, existingAccessory);
            usedAccessory = existingAccessory;
        }
        else {
            this.log.info(`No accessory found with UUID ${uuid}`);
            this.log.info('Creating a new temperature sensor accessory');
            const accessory = new this.api.platformAccessory(configuration.name, uuid);
            // store a copy of the device object in the `accessory.context`
            // the `context` property can be used to store any data about the accessory you may need
            accessory.context.device_type = 'sensor';
            accessory.context.device_class = 'temperature';
            accessory.context.configuration = configuration;
            // create the accessory handler for the newly create accessory
            // this is imported from `platformAccessory.ts`
            new temperatureSensorAccessory_1.TemperatureSensorPlatformAccessory(this, accessory);
            // link the accessory to your platform
            this.api.registerPlatformAccessories(settings_1.PLUGIN_NAME, settings_1.PLATFORM_NAME, [accessory]);
            usedAccessory = accessory;
        }
        (_a = this.client) === null || _a === void 0 ? void 0 : _a.subscribe(usedAccessory.context.configuration.state_topic);
    }
    handleHumiditySensorConfiguration(uuid, existingAccessory, configuration) {
        var _a;
        let usedAccessory;
        if (existingAccessory) {
            this.log.info(`Found an accessory with UUID ${uuid}`);
            new humiditySensorAccessory_1.HumiditySensorPlatformAccessory(this, existingAccessory);
            usedAccessory = existingAccessory;
        }
        else {
            this.log.info(`No accessory found with UUID ${uuid}`);
            this.log.info('Creating a new humidity sensor accessory');
            const accessory = new this.api.platformAccessory(configuration.name, uuid);
            // store a copy of the device object in the `accessory.context`
            // the `context` property can be used to store any data about the accessory you may need
            accessory.context.device_type = 'sensor';
            accessory.context.device_class = 'humidity';
            accessory.context.configuration = configuration;
            // create the accessory handler for the newly create accessory
            // this is imported from `platformAccessory.ts`
            new temperatureSensorAccessory_1.TemperatureSensorPlatformAccessory(this, accessory);
            // link the accessory to your platform
            this.api.registerPlatformAccessories(settings_1.PLUGIN_NAME, settings_1.PLATFORM_NAME, [accessory]);
            usedAccessory = accessory;
        }
        (_a = this.client) === null || _a === void 0 ? void 0 : _a.subscribe(usedAccessory.context.configuration.state_topic);
    }
}
exports.HomeassistantHomebridgePlatform = HomeassistantHomebridgePlatform;
//# sourceMappingURL=platform.js.map